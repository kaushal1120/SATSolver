package ai.sat.dpll;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Implements the Dpll algorithm.
 * @author kps9907
 *
 */
public class DPLL {
	/**
	 * No. of literals generated by the given problem.
	 */
	private int noOfLiterals = 0;
	
	public DPLL(int noOfLiterals) {
		this.noOfLiterals = noOfLiterals;
	}

	/**
	 * Applies the DPLL algorithm on a set of clauses and bindings generated.
	 * @param clauses
	 * @param bindings
	 * @return boolean whether a satisfiable valuation is possible or not.
	 */
	public boolean solve(List<List<Integer>> clauses, Map<Integer, Boolean> bindings) {
		//Check for easy cases.
		do {
			if(clauses.size() == 0)
				return true;
			for(List<Integer> clause : clauses) {
				if(clause.size()==0)
					return false;
			}			
		} while (resolveEasyCases(clauses, bindings));

		//Create a copy of the clauses and their bindings.
		List<List<Integer>> clausesCopy = new ArrayList<List<Integer>>();
		for(int j = 0; j < clauses.size(); j++) {
			clausesCopy.add(new ArrayList<Integer>());
			for(int k = 0; k < clauses.get(j).size(); k++)
				clausesCopy.get(j).add(clauses.get(j).get(k).intValue());
		}
		//Create a copy of the bindings.
		Map<Integer, Boolean> bindingsCopy = new HashMap<Integer, Boolean>(bindings);
		bindingsCopy.putAll(bindings);
		int i = 0;
		//Find an unbound literal that can be binded.
		for(i = 1; i <= noOfLiterals; i++) {
			if(bindings.get(i)==null){
				propagate(clausesCopy,bindingsCopy,Math.abs(i),true);
				break;
			}
		}
		//Bind it with true and check if a satisfying valuation is found
		if(solve(clausesCopy,bindingsCopy)) {
			bindings.putAll(bindingsCopy);
			return true;
		}

		//If not try binding the same variable with false by creating another copy of clauses and bindings.
		clausesCopy = new ArrayList<List<Integer>>();
		for(int j = 0; j < clauses.size(); j++) {
			clausesCopy.add(new ArrayList<Integer>());
			for(int k = 0; k < clauses.get(j).size(); k++)
				clausesCopy.get(j).add(clauses.get(j).get(k).intValue());
		}
		bindingsCopy = new HashMap<Integer, Boolean>();
		bindingsCopy.putAll(bindings);
		propagate(clausesCopy,bindingsCopy,Math.abs(i),false);
		//Check if this new binding gives a satisfying valuation.
		if(solve(clausesCopy,bindingsCopy)) {
			bindings.putAll(bindingsCopy);
			return true;
		}
		//Return false if neither true nor false can be bound to a literal.
		return false;
	}

	/**
	 * Resolves the easy cases in the dpll algorithm corresponding to the singleton clause and pure literal.
	 * @param clauses
	 * @param bindings
	 * @return boolean whether an easy case was found in this method run or not.
	 */
	private boolean resolveEasyCases(List<List<Integer>> clauses, Map<Integer, Boolean> bindings) {
		boolean easyCaseFound = false;
		//Checks for the singleton clause.
		for(int i = 0; i < clauses.size(); i++) {
			if(clauses.get(i).size()==1) {
				easyCaseFound = true;
				if(clauses.get(i).get(0) < 0)
					i = Math.max(0, i - propagate(clauses, bindings, Math.abs(clauses.get(i).get(0).intValue()), false));
				else
					i = Math.max(0, i - propagate(clauses, bindings, Math.abs(clauses.get(i).get(0).intValue()), true));
			}
		}

		//Checks for a pure literal
		int possiblePureLiteral;
		boolean literalFoundFlag;
		boolean isPureLiteral;
		for(int i = 1; i <= noOfLiterals; i++) {
			possiblePureLiteral = i;
			literalFoundFlag = false;
			isPureLiteral = true;
			for(int j = 0; j < clauses.size() && isPureLiteral; j++) {
				for(int k = 0; k < clauses.get(j).size() && isPureLiteral; k++) {
					if(!literalFoundFlag && Math.abs(clauses.get(j).get(k).intValue()) == possiblePureLiteral) {
						possiblePureLiteral = clauses.get(j).get(k).intValue();
						literalFoundFlag = true;
					} else if(literalFoundFlag && Math.abs(clauses.get(j).get(k).intValue()) == Math.abs(possiblePureLiteral)) {
						if(clauses.get(j).get(k).intValue() == possiblePureLiteral)
							continue;
						else
							isPureLiteral = false;
					}
				}
			}
			if(isPureLiteral && literalFoundFlag) {
				if(possiblePureLiteral < 0)
					propagate(clauses, bindings, Math.abs(possiblePureLiteral), false);
				else
					propagate(clauses, bindings, Math.abs(possiblePureLiteral), true);
				easyCaseFound = true;
			}
		}
		return easyCaseFound;
	}

	/**
	 * Adds a new binding as specified. Propagates the changes made by the binding to the list of clauses.
	 * @param clauses
	 * @param bindings
	 * @param A
	 * @param V
	 * @return int no of clauses deleted from the passed clause list.
	 */
	private int propagate(List<List<Integer>> clauses, Map<Integer, Boolean> bindings, int A, boolean V) {
		bindings.put(A, V);
		int noOfClausesDeleted = 0;
		for(int i = 0; i < clauses.size(); i++) {
			for(int j = 0; j < clauses.get(i).size(); j++) {
				if(A==clauses.get(i).get(j).intValue() && V || A+clauses.get(i).get(j).intValue() == 0 && !V) {					
					clauses.remove(i);
					i--;
					noOfClausesDeleted++;
					break;
				}
				else if(A+clauses.get(i).get(j).intValue()==0 && V || A==clauses.get(i).get(j).intValue() && !V) {
					clauses.get(i).remove(j);
					j--;
				}
			}
		}
		return noOfClausesDeleted;
	}
}
